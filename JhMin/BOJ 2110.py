# https://www.acmicpc.net/problem/2110

''' 오답 코드
def find_mid(array: list, find_number: int):
    left, right = 0, len(array) - 1

    while left <= right:

        mid = (left + right) // 2

        if find_number == array[mid]:
            break

        elif find_number < array[mid]:
            right = mid - 1

        elif find_number > array[mid]:
            left = mid + 1
    
    return mid

        

import sys
input = sys.stdin.readline

N, C = map(int, input().split())


arr = []
for i in range(N):
    arr.append(int(input()))
arr.sort()

checked_arr = [0] * N


find_list = []

for i in range(C + 1):
    find_list.append(arr[N - 1] / C * i)


for i in range(C):
    target = find_mid(arr, find_list[i])
    checked_arr[target] = 1


for i in checked_arr:
    print(i)
'''

'''ChatGPT 피드백

1. 문제 이해와 접근 방식
문제 목표:
이 문제는 집들이 임의의 위치에 있을 때, C개의 공유기를 설치하여 “공유기 사이의 최소 거리를 최대화”하는 문제야.
전형적인 해결 방법은 파라메트릭 서치(Parametric Search) 기법을 활용하는 것으로,
“특정 거리 d를 유지하며 공유기를 C개 설치할 수 있는가?”
라는 결정 문제를 그리디 알고리즘으로 체크한 뒤, 가능한 d의 최댓값을 이진 탐색으로 찾는 방식이야.

너의 접근 방식:
집 좌표를 정렬한 것은 좋았어.
다만, find_list를 계산할 때 arr[N - 1] / C * i 식으로 이론상 균등 간격을 가정하는 방식은 집들이 실제로 균등 분포되어 있지 않을 수 있기 때문에 문제가 발생해.
find_mid 함수를 통해 후보 좌표와 일치하는 집의 인덱스를 찾으려는 시도는,
실제로는 “특정 거리 d로 공유기를 설치할 수 있는지”를 판단하는 그리디 함수와는 성격이 달라.

2. 코드 구성 및 문제점
find_mid 함수:
이진 탐색을 구현하려는 시도는 괜찮지만,
만약 find_number가 배열에 없으면 루프 종료 후 반환하는 mid 값이 실제 원하는 집의 인덱스가 아닐 수 있음.
문제에서는 특정 값을 찾는 것보다, “현재 위치에서 d 이상의 간격을 확보할 수 있는 다음 집”을 찾는 게 더 유용함.

find_list 계산:
find_list를 집의 최대 좌표를 기준으로 균등하게 나눈 값들을 저장하는데,
이는 집들이 임의의 위치에 있을 때 적절한 후보 위치가 아닐 가능성이 높아.
문제의 핵심은 공유기 설치 위치 선택이 집들의 분포에 따라 결정되어야 한다는 점이야.

공유기 설치 로직 (checked_arr 업데이트):
현재 코드에서는 find_list의 각 값에 대해 해당하는 인덱스를 찾아 checked_arr[target] = 1로 표시하고 있어.
그러나 문제에서는 단순히 어느 집에 설치할지를 결정하는 것이 아니라,
**설치 가능한 “최대 최소 거리”**를 계산해야 해.
출력 부분도 0과 1의 배열을 출력하는데, 이는 문제의 요구사항(최대 최소 거리 한 개의 정수 출력)와 다름.

3. 개선 방향
문제 재해석 및 결정 문제 접근:
“주어진 거리 d를 최소 거리로 두고 C개의 공유기를 설치할 수 있는지”를 판단하는 함수를 작성해 보자.
예를 들어, 첫 번째 집에 공유기를 설치한 후, 그 다음 집부터 현재 설치한 위치와의 거리가 d 이상인 경우에만 공유기를 설치하는 식으로 진행해.

이진 탐색을 통한 d 값 탐색:
가능한 최소 거리의 범위는 최소 1부터 (마지막 집 - 첫 번째 집)까지로 설정할 수 있어.
이 범위 내에서 d의 최댓값을 찾는 방식으로 이진 탐색을 구현하면 문제의 조건에 맞게 풀 수 있어.

코드의 구조와 변수 이름 개선:
각 함수의 역할(예: 결정 함수, 이진 탐색 함수)을 명확하게 나누어 두면 가독성이 높아질 거야.
find_mid와 같이 단순 이진 탐색을 사용하기보다는, 문제에 맞게 “공유기 설치 가능 여부”를 판단하는 함수로 변경하는 게 좋겠어.

출력 및 결과:
최종적으로 출력해야 하는 값은 최대 가능한 최소 거리이므로,
설치 여부를 나타내는 배열 대신 그 값을 출력하도록 수정해야 해.

4. 요약
장점:
집 좌표 정렬과 입력 처리 방식은 잘 작성되어 있음.
이진 탐색을 시도한 점은 문제 해결 아이디어로 볼 때 긍정적.

개선할 점:
문제의 핵심인 “최대 최소 거리” 문제에 맞게 접근 방식을 전환할 필요가 있음.
균등 간격을 가정하는 대신, 실제 집들의 분포에 기반한 그리디 체크 함수를 구현해 보자.
find_mid 함수 대신, “공유기 설치 가능 여부”를 판단하는 별도의 함수로 대체하는 것이 좋음.
최종 출력은 설치 위치가 아니라 계산된 최대 최소 거리를 출력해야 함.
이런 피드백을 바탕으로 코드를 다시 한 번 구조화해보고, 결정 문제 접근 방식으로 전환해보면 좋을 것 같아.
'''


# 해답 코드
import sys

def is_possible(distance, houses, C):
    """
    주어진 최소 거리(distance)를 유지하면서 공유기를 설치할 수 있는지 확인하는 함수.
    houses: 정렬된 집의 좌표 리스트
    C: 설치해야 할 공유기 개수
    """
    count = 1                # 첫 번째 집에 공유기를 무조건 설치
    last_installed = houses[0]
    
    # 두 번째 집부터 순회하면서, 이전에 설치한 공유기와의 거리가
    # distance 이상인 경우에만 공유기를 설치
    for i in range(1, len(houses)):
        if houses[i] - last_installed >= distance:
            count += 1
            last_installed = houses[i]
            if count >= C:   # 필요한 공유기를 모두 설치했다면
                return True
    return False

def main():
    input = sys.stdin.readline
    N, C = map(int, input().split())
    houses = [int(input().strip()) for _ in range(N)]
    houses.sort()
    
    # 가능한 최소 거리의 범위:
    # 최소: 1, 최대: 맨 오른쪽 집과 맨 왼쪽 집 사이의 거리
    left, right = 1, houses[-1] - houses[0]
    answer = 0

    # 이진 탐색: 가능한 거리 중 최대값을 찾는다.
    while left <= right:
        mid = (left + right) // 2    # 후보 최소 거리
        if is_possible(mid, houses, C):
            answer = mid             # mid 거리로 설치 가능한 경우, 정답 갱신
            left = mid + 1           # 더 큰 거리로 설치가 가능한지 탐색
        else:
            right = mid - 1          # mid 거리로 설치가 불가능하면, 거리를 줄여본다.
    
    print(answer)

if __name__ == '__main__':
    main()

'''해답코드 해설
문제 접근법 이해
문제 핵심은 “최소 간격의 최댓값”을 찾는 거야. 즉, 공유기들 간의 최소 거리를 최대로 만들고 싶어.
이를 위해 결정 문제(Decision Problem) 접근법을 사용했어. 즉, 주어진 후보 거리로 공유기를 C개 설치할 수 있는지 확인하는 함수를 구현한 후, 이진 탐색으로 가능한 거리의 최댓값을 찾는 방식이지.

is_possible 함수
함수 내부에서 그리디 알고리즘을 활용해, 첫 번째 집에는 무조건 공유기를 설치하고, 그 후 순차적으로 “현재 집과 마지막으로 설치한 집의 거리 ≥ 후보 거리”인 경우에만 공유기를 설치하고 있어.
공유기를 C개 설치할 수 있으면 True를 반환하는 구조는 결정 문제의 전형적인 패턴이야.

이진 탐색 구현
탐색 범위 설정: 최소 거리는 1부터 시작하며, 최대 거리는 정렬된 집 좌표에서 맨 끝과 맨 앞의 차이로 설정했어.
탐색 과정: 중간값(mid)을 후보 거리로 두고, 가능 여부를 판단한 후에 가능한 경우에는 더 큰 값으로, 불가능한 경우에는 더 작은 값으로 탐색 범위를 좁혀가는 방식이 잘 구현되어 있어.
정답 갱신: 후보 거리가 가능한 경우마다 answer를 갱신하여 마지막에 최대 가능한 최소 거리를 출력하도록 한 점도 좋았어.

입출력 처리
빠른 입출력을 위해 sys.stdin.readline을 사용한 점도 문제 규모가 큰 경우에 적합해.
집 좌표를 입력받은 후 strip()을 사용해 불필요한 공백 제거를 해준 점도 꼼꼼해.

코드 가독성
함수와 변수의 이름이 역할을 명확히 표현하고 있어, 코드 읽는 사람이 이해하기 쉽게 구성되어 있어.
주석을 통해 각 부분의 역할을 설명해둬서, 다른 사람이나 미래의 자신이 코드를 볼 때 이해하기 쉽도록 했어.

추가 고려 사항
만약 집 좌표가 매우 큰 수들이거나 집의 개수가 많다면, 이진 탐색의 시간 복잡도와 그리디 체크 함수의 효율성이 결정적인데, 이 코드에서는 이를 잘 반영하고 있어.
혹시 디버깅이 필요할 경우, 각 단계에서 후보 거리와 공유기 설치 여부를 출력해보는 것도 좋지만, 최종 제출 코드에서는 불필요한 출력은 제거하는 것이 좋아.
'''